'use strict';

const bluebird  = require('bluebird');
const _         = require('lodash');
const path      = require('path');
const jszip     = require('jszip');
const fs        = require('fs');
const minimatch = require('minimatch');

const munge  = require('./serverless-cljs-plugin/munge');
const mkdirp = bluebird.promisify(require('mkdirp'));
const exec   = bluebird.promisify(require('child_process').exec,
                                  {multiArgs: true});

jszip.external.Promise = bluebird;

const DEFAULT_EXCLUDE = ['node_modules/serverless-cljs-plugin/**'];

function destroyFnMap(service) {
  return _.mapValues(
    service.functions,
    fn => {
      if(fn.cljs) {
        fn.handler = `index.${munge.munge(fn.cljs)}`;
        _.set(fn, 'package.artifact', service.__cljsArtifact);
      }
      return fn;
    });
}

function edn(v) {
  if (_.isArray(v)) {
    return '[' + v.map(edn).join(' ') + ']';
  }
  if (_.isPlainObject(v)) {
    return '{' + _.map(v, (v, k) => ':' + k + ' ' + edn(v)).join(' ') + '}';
  }
  return v;
}

function slsToCljsLambda(functions, opts) {
  return _(functions)
    .pickBy((v, k) => v.cljs && (opts.function ? k === opts.function : true))
    .values()
    .map   (m => {
      return {name: `"${m.name}"`, invoke: m.cljs};
    })
    .thru  (edn)
    .value ();
}

function basepath(config, service, opts) {
  return `${config.servicePath}/.serverless/${opts.function || service.service}`;
}

const readFile = bluebird.promisify(fs.readFile);
const writeFile = bluebird.promisify(fs.writeFile);

const applyZipExclude = bluebird.coroutine(
  function*(serverless, opts) {
    // TODO respect exclude on individual functions
    const exclude = _.uniq(_.get(serverless.service.package, "exclude", []));

    if (!_.isEmpty(exclude)) {
      const data   = yield readFile(serverless.service.__cljsArtifact);
      const oldZip = yield jszip.loadAsync(data);
      const newZip = jszip();

      oldZip
        .filter((path, file) => !_.some(exclude, pattern => minimatch(path, pattern)))
        .forEach(entry => newZip.file(entry.name,
                                      entry.nodeStream("nodebuffer"),
                                      _.pick(entry, ["unixPermissions", "dosPermissions", "comment", "date"])));

      const buffer = yield newZip.generateAsync({
        type:        "nodebuffer",
        platform:    process.platform,
        compression: "DEFLATE",
        comment:     `Generated by serverless-cljs-plugin on ${new Date().toISOString()}`});

      yield writeFile(serverless.service.__cljsArtifact, buffer);
    }
  });

function lumoClasspath(lumo) {
  if(lumo.classpath) {
    const cp = _.isString(lumo.classpath) ? lumo.classpath : lumo.classpath.join(':');
    return `--classpath ${cp}`;
  }
}

function lumoDependencies(lumo) {
  if(lumo.dependencies) {
    const d = _.isString(lumo.dependencies) ? lumo.dependencies : lumo.dependencies.join(',');
    return `--dependencies ${d}`
  }
}

function lumoLocalRepo(lumo) {
  if(lumo.localRepo) {
    return `--local-repo ${lumo.localRepo}`;
  }
}

function cljsLambdaBuild(serverless, opts) {
  const fns      = slsToCljsLambda(serverless.service.functions, opts);
  const compiler = _.get(serverless.service, 'custom.cljsCompiler');
  const index    = _.get(serverless.service, 'custom.cljsIndex');
  const lumo     = _.get(compiler, 'lumo', {});

  let cmd;
  if(compiler == "lumo" || opts.lumo || _.some(lumo)) {
    const args = _.some(lumo) ? _.filter([lumoClasspath(lumo),
                                          lumoDependencies(lumo),
                                          lumoLocalRepo(lumo)]) : [];
    cmd = (`lumo ${args.join(' ')} -c ${path.resolve(__dirname, 'serverless-cljs-plugin')} ` +
           `-m serverless-lumo.build ` +
           `--zip-path ${serverless.service.__cljsArtifact} ` +
           `--functions '${fns}' ` +
           `--index ${_.defaultTo(opts.index || index, false)}`);
  } else {
    cmd = (`lein update-in :cljs-lambda assoc :functions '${fns}' ` +
           `-- cljs-lambda build :output ${serverless.service.__cljsArtifact} ` +
           `:quiet`);
  }

  serverless.cli.log(`Executing "${cmd}"`);
  return exec(cmd);
};

const after_createDeploymentArtifacts = bluebird.coroutine(
  function*(serverless, opts) {
    yield mkdirp(`${serverless.config.servicePath}/.serverless`);

    yield cljsLambdaBuild(serverless, opts);

    yield applyZipExclude(serverless, opts);

    serverless.cli.log(`Returning artifact path ${serverless.service.__cljsArtifact}`);
    return serverless.service.__cljsArtifact;
  });

class ServerlessPlugin {
  constructor(serverless, opts) {
     _.update(
       serverless.service, 'package.exclude', v => _.concat(v || [], DEFAULT_EXCLUDE));

    opts.function = (opts.f || opts.function);

    serverless.service.__cljsBasePath = (
      `${basepath(serverless.config, serverless.service, opts)}`);
    serverless.service.__cljsArtifact= `${serverless.service.__cljsBasePath}.zip`;

    serverless.cli.log(`Targeting ${serverless.service.__cljsArtifact}`);

    destroyFnMap(serverless.service);

    const buildAndMerge = after_createDeploymentArtifacts.bind(
      null, serverless, opts);

    this.hooks = {
      'after:deploy:createDeploymentArtifacts': buildAndMerge,
      'after:deploy:function:packageFunction': buildAndMerge
    };
  }
}

module.exports = ServerlessPlugin;
