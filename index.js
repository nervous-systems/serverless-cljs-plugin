'use strict';

const bluebird  = require('bluebird');
const _         = require('lodash');
const path      = require('path');
const jszip     = require('jszip');
const fs        = require('fs');
const minimatch = require('minimatch');

const munge  = require('./serverless-cljs-plugin/munge');
const mkdirp = bluebird.promisify(require('mkdirp'));
const exec   = bluebird.promisify(require('child_process').exec,
                                  {multiArgs: true});

jszip.external.Promise = bluebird;

const DEFAULT_EXCLUDE = ['node_modules/serverless-cljs-plugin/**', '.lumo_cache/**'];

function isLumo(serverless, opts) {
  const compiler = _.get(serverless.service, 'custom.cljsCompiler');
  const lumo     = _.get(compiler, 'lumo', {});
  return (compiler == "lumo" || opts.lumo || _.some(lumo));
}

function setCljsLambdaFnMap(serverless, opts) {
  return _.mapValues(
    serverless.service.functions,
    fn => {
      if(fn.cljs) {
        fn.handler = `index.${munge.munge(fn.cljs)}`;
        if(!isLumo(serverless, opts)) {
          fn.artifact = serverless.service.__cljsArtifact;
        }
      }
      return fn;
    });
}

function setCljsLambdaExclude(serverless) {
  return _.update(serverless.service, 'package.exclude', v => _.concat(v || [], DEFAULT_EXCLUDE));
}

function edn(v) {
  if (_.isArray(v)) {
    return '[' + v.map(edn).join(' ') + ']';
  }
  if (_.isPlainObject(v)) {
    return '{' + _.map(v, (v, k) => ':' + k + ' ' + edn(v)).join(' ') + '}';
  }
  return v;
}

function slsToCljsLambda(functions, opts) {
  return _(functions)
    .pickBy((v, k) => v.cljs && (opts.function ? k === opts.function : true))
    .values()
    .map   (m => {
      return {name: `"${m.name}"`, invoke: m.cljs};
    })
    .thru  (edn)
    .value ();
}

function basepath(config, service, opts) {
  return `${config.servicePath}/.serverless/${opts.function || service.service}`;
}

const readFile = bluebird.promisify(fs.readFile);
const writeFile = bluebird.promisify(fs.writeFile);

const applyZipExclude = bluebird.coroutine(
  function*(serverless, opts) {
    // TODO respect exclude/include on individual functions
    const exclude = _.uniq(_.get(serverless.service.package, "exclude", []));

    if (!_.isEmpty(exclude)) {
      const data   = yield readFile(serverless.service.__cljsArtifact);
      const oldZip = yield jszip.loadAsync(data);
      const newZip = jszip();

      oldZip
        .filter((path, file) => !_.some(exclude, pattern => minimatch(path, pattern)))
        .forEach(entry => newZip.file(entry.name,
                                      entry.nodeStream("nodebuffer"),
                                      _.pick(entry, ["unixPermissions", "dosPermissions", "comment", "date"])));

      const buffer = yield newZip.generateAsync({
        type:        "nodebuffer",
        platform:    process.platform,
        compression: "DEFLATE",
        comment:     `Generated by serverless-cljs-plugin on ${new Date().toISOString()}`});

      yield writeFile(serverless.service.__cljsArtifact, buffer);
    }
  });

function lumoClasspath(lumo) {
  let cp = path.resolve(__dirname, 'serverless-cljs-plugin');
  if(lumo.classpath) {
    cp = _.isString(lumo.classpath) ? `${cp}:${lumo.classpath}` : `${cp}:${lumo.classpath.join(':')}`;
  }
  return `--classpath ${cp}`;
}

function lumoDependencies(lumo) {
  if(lumo.dependencies) {
    const d = _.isString(lumo.dependencies) ? lumo.dependencies : lumo.dependencies.join(',');
    return `--dependencies ${d}`;
  }
}

function lumoLocalRepo(lumo) {
  if(lumo.localRepo) {
    return `--local-repo ${lumo.localRepo}`;
  }
}

function lumoCache(lumo) {
  if(!lumo.cache) {
    return "--auto-cache";
  } else {
    if(lumo.cache != "none") {
      return `--cache ${lumo.cache}`;
    }
  }
}

function cljsLambdaBuild(serverless, opts) {
  const fns      = slsToCljsLambda(serverless.service.functions, opts);
  const compiler = _.get(serverless.service, 'custom.cljsCompiler');
  const lumo     = _.get(compiler, 'lumo', {});
  const exitOnWg = _.get(lumo, 'exitOnWarning');
  const index    = _.get(lumo, 'index');

  let cmd;
  if(isLumo(serverless, opts)) {
    const args =  _.filter([lumoClasspath(lumo),
                            lumoDependencies(lumo),
                            lumoLocalRepo(lumo),
                            lumoCache(lumo)]);
    cmd = (`lumo ${args.join(' ')} ` +
           `--main serverless-lumo.build ` +
           `--service-path ${serverless.config.servicePath} ` +
           `--functions '${fns}' ` +
           `--index ${_.defaultTo(opts.index || index, false)} ` +
           `--warning-exit ${_.defaultTo(opts.exitOnWarning || exitOnWg, false)}`);
  } else {
    cmd = (`lein update-in :cljs-lambda assoc :functions '${fns}' ` +
           `-- cljs-lambda build :output ${serverless.service.__cljsArtifact} ` +
           `:quiet`);
  }

  serverless.cli.log(`Executing "${cmd}"`);
  return exec(cmd);
}

const after_createDeploymentArtifacts = bluebird.coroutine(
  function*(serverless, opts) {
    yield mkdirp(`${serverless.config.servicePath}/.serverless`);

    yield cljsLambdaBuild(serverless, opts);

    if(!isLumo(serverless, opts)) {
      yield applyZipExclude(serverless, opts);
    }

    serverless.cli.log(`Returning artifact path ${serverless.service.__cljsArtifact}`);
    return serverless.service.__cljsArtifact;
  });

class ServerlessPlugin {
  constructor(serverless, opts) {

    opts.function = (opts.f || opts.function);

    serverless.service.__cljsBasePath = (
      `${basepath(serverless.config, serverless.service, opts)}`);
    serverless.service.__cljsArtifact= `${serverless.service.__cljsBasePath}.zip`;

    serverless.cli.log(`Targeting ${serverless.service.__cljsArtifact}`);

    setCljsLambdaFnMap(serverless, opts);
    setCljsLambdaExclude(serverless);

    const buildAndMerge = after_createDeploymentArtifacts.bind(
      null, serverless, opts);

    const when = isLumo(serverless, opts) ? 'before' : 'after';

    // Using the same hooks as in graphcool/serverless-plugin-typescript:
    // https://github.com/graphcool/serverless-plugin-typescript/blob/master/src/index.ts#L39
    this.hooks = {
      [`${when}:package:createDeploymentArtifacts`]: buildAndMerge,
      [`${when}:deploy:function:packageFunction`]: buildAndMerge
    };
  }
}

module.exports = ServerlessPlugin;
